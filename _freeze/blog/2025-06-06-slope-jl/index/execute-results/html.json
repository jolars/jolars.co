{
  "hash": "6a3f9276fc646f94fabfbdf3e4c1ec2b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"SLOPE for Python and Julia\"\nauthor: Johan Larsson\ndate: 2025-06-06\ndescription: |\n  The SLOPE package universe expands to Python and Julia\ncategories:\n  - Software\n  - Julia\n  - R\n  - Python\n  - SLOPE\n  - C++\nimage: logo.png\nreference-location: margin\nengine: knitr\n---\n\nI am excited to announce that SLOPE is now also available to users of Julia and\nPython! The Python package, [sortedl1]() has in fact been available for over a\nyear now, but the Julia package\n([SLOPE.jl](https://github.com/jolars/SLOPE.jl)) was just added to the general\nregistry.\n\nThis is the culmnination of a several months long effort to rewrite the C++\nbackend of SLOPE from scratch and refactor into into a separate library,\n[slope](https://github.com/jolars/libslope).\nCompared to the previous backend, which was entirely designed as a\ndriver for the R package [SLOPE](https://) and based on the RcppArmadillo package,\nthis new version is built as a standalone library that could, in principle, be used\non its own. All of the unit tests (and several more) are now part of this library\ninstead of the R package, which mitigates some of the awkward practicies of\nhaving to export C++ functions to R just to be able to unit test them.\n\nThe purpose of all of this is to make it easier to use SLOPE in other languages,\nin particular Julia and Python. The idea is that all of these packages will be able\nto use the new backend by simply using the source code directly as part of the\nrespective build system. I originally experimented with a direct\napproach wherein the bindings for each language would be generated\ndirectly from the C++ repository, which is what [mlpack](https://github.com/mlpack/mlpack)\ndoes, but this makes developing the bindings cumbersome and unfriendly\nto new contributors. Instead, I have opted for a more traditional\napproach where each package lives in its own repository.\nNevertheless, the idea is for each of these bindings to be able\nto easily update to the latest versio nof the C++ library by simply\npulling the latest release of the C++ library.\n\nThe particular details of how this is done in\neach language is something that I will leave to another post as it is\ninteresting in itself and highlights some of the differences between\nthe languages and their package ecosystems, which I have learned a lot\nabout during this process.\n\nFor now, however, we will just focus on the package suite.\n\n\n\n::: {.panel-tabset}\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sortedl1 import Slope\n\nimport numpy as np\n\nn = 100\np = 10\nk = 2\nx = np.random.randn(n, p)\nbeta = np.zeros(p)\nbeta[:k] = 1\ny = x @ beta + np.random.randn(n)\nmodel = Slope()\n\nfit = model.fit(x, y)\n```\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SLOPE)\n\nn <- 100\np <- 10\nk <- 2\n\nx <- matrix(rnorm(n * p), n)\nbeta <- double(p)\nbeta[1:k] <- 1\n\ny <- x %*% beta + rnorm(n)\n\nfit <- SLOPE(x, y)\n\nplot(fit)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Julia\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing SLOPE\nusing Plots\n\nn = 100;\np = 10;\nk = 2;\n\nx = randn(n, p);\nbeta = zeros(p);\nbeta[1:k] .= 1;\ny = x * beta + randn(n);\n\nfit = slope(x, y);\n\nplot(fit)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-J1.png){width=300}\n:::\n:::\n\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}